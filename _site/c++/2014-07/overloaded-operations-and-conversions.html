<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Overloaded Operations and Conversions - My study notes</title>
  <meta name="description" content="">
  <meta name="keywords" content="">
  <meta name="author" content="liuguichao">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="shortcut icon" href="/favicon.png">
  <link rel="canonical" href="/c++/2014-07/overloaded-operations-and-conversions.html">

  <link rel="stylesheet" href="/assets/css/style.css" media="all">

  <!-- atom & rss feed -->
  <link href="/rss.xml" type="application/rss+xml" rel="alternate" title="My study notes RSS Feed">
  <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="My study notes ATOM Feed">

  <!-- fav and touch icons  -->
  <!-- Update these with your own images
  <link rel="shortcut icon" href="images/favicon.ico">
  <link rel="apple-touch-icon" href="images/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.png">
  -->

  <meta name="renderer" content="webkit|ie-stand">

  <meta name="baidu-site-verification" content="BvD3CNBzK6" />
  <meta name="msvalidate.01" content="FE0D1D87A075E1003B82C7446EE360ED" />
</head>


  <body>
    <div class="container">
      <!--[if lt IE 9]>
<div class="alert alert-warning">
  <p>Your Internet Explorer is not supported. Please upgrade your Internet Explorer to version 9+, or use latest <a href="http://www.google.com/chrome/" target="_blank" class="alert-link">Google chrome</a>、<a href="http://www.mozilla.org/firefox/" target="_blank" class="alert-link">Mozilla Firefox</a>.</p>
  <p>If you are using IE 9 or later, make sure you <a href="http://windows.microsoft.com/en-us/internet-explorer/use-compatibility-view#ie=ie-8" target="_blank" class="alert-link">turn off "Compatibility view"</a>.</p>
</div>
<![endif]-->
<header class="header">
  <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
  <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target=".bs-navbar-collapse">
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
  </button>
  <div class="title"><a title="My study notes" href="/">My study notes</a></div>
  <ul class="nav navbar-nav collapse navbar-collapse bs-navbar-collapse navbar-right">
    <li>
    <form id="search-form" class="form-group has-success visible-lg" role="form">
      <input type="text" class="form-control input-sm" placeholder="Search" id="query">
    </form>
    </li>
    <li><a href="/archive.html" title="Archive"><span class='fa fa-archive fa-2x'></span></a></li>
    <li><a href="/categories.html" title="Categories" rel="nofollow"><span class='fa fa-navicon fa-2x'></span></a></li>
    <li><a href="/tags.html" title="Tags" rel="nofollow"><span class='fa fa-tags fa-2x'></span></a></li>
    <li><a href="/about.html" title="About"><span class='fa fa-user fa-2x'></span></a></li>
    
    <li><a href="https://github.com/liuguichao" target="_blank" title="Github" rel="nofollow"><span class='fa fa-github fa-2x'></span></a></li>
    
    
    
    
    

    <li><a href="/rss.xml" target="_blank" title="RSS" rel="nofollow"><span class='fa fa-rss fa-2x'></span></a></li>
  </ul>
</header>


      <article class="wrapper">
        <div id="search-loader" class="img-wrap">
          <div class="loading">
            <img src="/assets/img/loading.png">
          </div>
        </div>
        <div class="row clearfix">
          <div class="col-md-12">
<h2 class="title"> Overloaded Operations and Conversions <time class="small">2014.07.18</time></h2>
<p>When an overloaded operator is a member function, <strong>this</strong> is bound to the
<strong>left-hand operand</strong>. Member operator functions have one less (explicit)
parameter than the number of operands.</p>

<p><strong>Calling an Overloaded Operator Function Directly</strong></p>
<div class="highlight"><pre><code class="language-C++" data-lang="C++"><span class="c1">// equivalent calls to a nonmember operator function</span>
<span class="n">data1</span> <span class="o">+</span> <span class="n">data2</span><span class="p">;</span>  <span class="c1">// normal expression</span>
<span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="n">data2</span><span class="p">);</span> <span class="c1">// equivalent function cal</span>

<span class="n">data1</span><span class="o">+=</span> <span class="n">data2</span><span class="p">;</span>  <span class="c1">// expression-based &#39;&#39;call&#39;&#39;</span>
<span class="n">data1</span><span class="p">.</span><span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="n">data2</span><span class="p">);</span>  <span class="c1">// equivalent call to a member operator function</span>
</code></pre></div>
<p>Ordinarily,the comma, address-of, logical AND, and logical OR operators
should notbe overloaded.Users of the class will be surprised if these operators behave differently from their normal meanings.</p>

<p><strong>Choosing Member or Nonmember Implementation</strong></p>

<ul>
<li>The assignment (=), subscript ([]), call (()), and member access arrow (-&gt;) operators must be defined as members.</li>
<li>The compound-assignment operators ordinarily oughtto be members. However,
unlike assignment, they are not required to be members.</li>
<li>Operators that change the state of their object or that are closely tied to their given type—such as increment, decrement, and dereference—usually should be members.</li>
<li>Symmetric operators—those that might convert either operand, such as the
arithmetic, equality, relational, and bitwise operators—usually should be defined as ordinary nonmember functions.</li>
</ul>

<p>When we define an operator as a member function, then the left-hand operand
must be an object of the class of which that operator is a member. </p>
<div class="highlight"><pre><code class="language-C++" data-lang="C++"><span class="n">strings</span> <span class="o">=</span> <span class="s">&quot;world&quot;</span><span class="p">;</span>
<span class="n">string</span> <span class="n">t</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="s">&quot;!&quot;</span><span class="p">;</span>  <span class="c1">// ok: we can add a const char* to a string</span>
<span class="n">string</span> <span class="n">u</span> <span class="o">=</span> <span class="s">&quot;hi&quot;</span> <span class="o">+</span> <span class="n">s</span><span class="p">;</span> <span class="c1">// would be an error if + were a member of string</span>
</code></pre></div>
<p>If operator+ were a member of the string class, the first addition would be
equivalent to s.operator+(&quot;!&quot;). Likewise, &quot;hi&quot; + swould be equivalent to
&quot;hi&quot;.operator+(s). However, the type of &quot;hi&quot; is const char*, and that is a
built-in type; it does not even have member functions.</p>

<p><strong>Overloading the Output Operator &lt;&lt;</strong></p>

<p>Ordinarily, the first parameter of an output operator is a reference to a nonconst ostream object. The ostream is nonconst because writing to the stream changes its state. The parameter is a reference because we cannot copy an ostream object.</p>

<p>The second parameter ordinarily should be a reference to const of the class type we want to print. The parameter is a reference to avoid copying the argument. It can be const because (ordinarily) printing an object does not change that object.</p>

<p>To be consistent with other output operators, operator&lt;&lt; normally returns its ostream parameter.</p>
<div class="highlight"><pre><code class="language-C++" data-lang="C++"><span class="n">ostream</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">Sales_data</span> <span class="o">&amp;</span><span class="n">item</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">item</span><span class="p">.</span><span class="n">isbn</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">item</span><span class="p">.</span><span class="n">units_sold</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span>
    <span class="o">&lt;&lt;</span> <span class="n">item</span><span class="p">.</span><span class="n">revenue</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">item</span><span class="p">.</span><span class="n">avg_price</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">os</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>Generally,output operators should print the contents of the object, with minimal formatting. They should not print a newline.</p>

<p><strong>IO Operators Must Be Nonmember Functions</strong></p>

<p>Input and output operators that conform to the conventions of the iostream library must be ordinary nonmember functions. These operators cannot be members of our own class. If they were, then the left-hand operand would have to be an object of our class type.</p>

<p>Thus,if we want to define the IO operators for our types, we must define them as nonmember functions. Of course, IO operators usually need to read or write the <strong>nonpublic</strong> data members. As a consequence, IO operators usually must be declared as <strong>friends</strong>.</p>

<p><strong>Overloading the Input Operator &gt;&gt;</strong></p>

<p>Ordinarily the first parameter of an input operator is a reference to the stream from which it is to read, and the second parameter is a reference to the (nonconst) object into which to read. The operator usually returns a reference to its given stream. The second parameter must be nonconst because the purpose of an input operator is to read data into this object.</p>
<div class="highlight"><pre><code class="language-C++" data-lang="C++"><span class="n">istream</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">istream</span> <span class="o">&amp;</span><span class="n">is</span><span class="p">,</span> <span class="n">Sales_data</span> <span class="o">&amp;</span><span class="n">item</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">double</span> <span class="n">price</span><span class="p">;</span>  <span class="c1">// no need to initialize; we&#39;ll read into price before we use it</span>
    <span class="n">is</span> <span class="o">&gt;&gt;</span> <span class="n">item</span><span class="p">.</span><span class="n">bookNo</span> <span class="o">&gt;&gt;</span> <span class="n">item</span><span class="p">.</span><span class="n">units_sold</span> <span class="o">&gt;&gt;</span> <span class="n">price</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">is</span><span class="p">)</span>  <span class="c1">// check that the inputs succeeded</span>
    <span class="n">item</span><span class="p">.</span><span class="n">revenue</span> <span class="o">=</span> <span class="n">item</span><span class="p">.</span><span class="n">units_sold</span> <span class="o">*</span> <span class="n">price</span><span class="p">;</span>
    <span class="k">else</span>
    <span class="n">item</span> <span class="o">=</span> <span class="n">Sales_data</span><span class="p">();</span> <span class="c1">// input failed: give the object the default state</span>
    <span class="k">return</span> <span class="n">is</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>Input operators must deal with the possibility that the input might fail; output operators generally don’t bother.</p>

<p><strong>Indicating Errors</strong></p>

<p>Usually an input operator should set only the failbit. Setting eof bit
would imply that the file was exhausted, and setting badbit would indicate that the stream was corrupted. These errors are best left to the IO library itself to indicate.</p>

<p><strong>Arithmetic and Relational Operators</strong></p>

<p>Ordinarily,we define the arithmetic and relational operators as nonmember functions in order to allow conversions for either the left- or right-hand operand. These operators shouldn’t need to change the state of either operand, so the parameters are ordinarily references to <strong>const</strong>.</p>
<div class="highlight"><pre><code class="language-C++" data-lang="C++"><span class="c1">// assumes that both objects refer to the same book</span>
<span class="n">Sales_data</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">Sales_data</span> <span class="o">&amp;</span><span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">Sales_data</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Sales_data</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">lhs</span><span class="p">;</span>  <span class="c1">// copy data members from lhs into sum</span>
    <span class="n">sum</span> <span class="o">+=</span> <span class="n">rhs</span><span class="p">;</span>  <span class="c1">// add rhs into sum</span>
    <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>Classes that define both an arithmetic operator and the related compound assignment ordinarily ought to implement the arithmetic operator by using
the compound assignment.</p>

<p><strong>Equality Operators</strong></p>
<div class="highlight"><pre><code class="language-C++" data-lang="C++"><span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">Sales_data</span> <span class="o">&amp;</span><span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">Sales_data</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">lhs</span><span class="p">.</span><span class="n">isbn</span><span class="p">()</span> <span class="o">==</span> <span class="n">rhs</span><span class="p">.</span><span class="n">isbn</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
    <span class="n">lhs</span><span class="p">.</span><span class="n">units_sold</span> <span class="o">==</span> <span class="n">rhs</span><span class="p">.</span><span class="n">units_sold</span> <span class="o">&amp;&amp;</span>
    <span class="n">lhs</span><span class="p">.</span><span class="n">revenue</span> <span class="o">==</span> <span class="n">rhs</span><span class="p">.</span><span class="n">revenue</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">Sales_data</span> <span class="o">&amp;</span><span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">Sales_data</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="n">lhs</span> <span class="o">==</span> <span class="n">rhs</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>Classes for which there is a logical meaning for equality normally should define operator==. Classes that define ==make it easier for users to use
the class with the library algorithms.</p>

<p><strong>Relational Operators</strong></p>

<p>Classes for which the equality operator is defined also often (but not always) have relational operators. In particular, because the associative containers and some of the algorithms use the less-than operator, it can be useful to define an <strong>operator&lt;</strong>.</p>

<p>Ordinarily the relational operators should</p>

<ol>
<li>Define an ordering relation that is consistent with the requirements for use as a key to an associative container; and</li>
<li>Define a relation that is consistent with ==if the class has both operators. In particular, if two objects are !=, then one object should be &lt;the other.</li>
</ol>

<p>If a single logical definition for &lt;exists, classes usually should define the &lt;operator. However, if the class also has ==, define &lt;only if the definitions of &lt;and ==yield consistent results.</p>

<p><strong>Assignment Operators</strong></p>

<p>In addition to the copy- and move-assignment operators that assign one object of the class type to another object of the same type,a class can define additional assignment operators that allow other types as the
right-hand operand.</p>

<p>As one example, in addition to the copy- and move-assignment operators, the library <strong>vector</strong> class defines a third assignment operator that takes a braced list of elements.</p>
<div class="highlight"><pre><code class="language-C++" data-lang="C++"><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
<span class="n">v</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="s">&quot;an&quot;</span><span class="p">,</span> <span class="s">&quot;the&quot;</span><span class="p">};</span>

<span class="n">classStrVec</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">StrVec</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">);</span>
    <span class="c1">// other members as in § 13.5 (p. 526)</span>
<span class="p">};</span>
</code></pre></div>
<p>Assignment operators can be overloaded. Assignment operators, regardless of parameter type, must be defined as member functions.</p>

<p><strong>Compound-Assignment Operators</strong></p>

<p>Compound assignment operators are not required to be members. However, we prefer to define all assignments, including compound assignments, in the class. For consistency with the built-in compound assignment, these operators should return a reference to their left-hand operand. </p>

<p>Assignment operators must, and ordinarily compound-assignment operators
should, be defined as members. These operators should return a reference to
the left-hand operand.</p>

<p><strong>Subscript Operator</strong></p>

<p>Classes that represent containers from which elements can be retrieved by position often define the subscript operator, <strong>operator[]</strong>. </p>

<p>The subscript operator must be a member function.</p>

<p>To be compatible with the ordinary meaning of subscript, the subscript operator usually returns a <strong>reference</strong> to the element that is fetched. By returning a reference, subscript can be used on either side of an assignment. Consequently, it is also usually a good idea to define both const and nonconst versions of this operator. When applied to a const object, subscript should return a reference to const so that it is
not possible to assign to the returned object.</p>
<div class="highlight"><pre><code class="language-C++" data-lang="C++"><span class="k">class</span> <span class="nc">StrVec</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span>
    <span class="p">{</span> <span class="k">return</span> <span class="n">elements</span><span class="p">[</span><span class="n">n</span><span class="p">];</span> <span class="p">}</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span> <span class="k">return</span> <span class="n">elements</span><span class="p">[</span><span class="n">n</span><span class="p">];</span> <span class="p">}</span>
    <span class="c1">// other members as in § 13.5 (p. 526)</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">*</span><span class="n">elements</span><span class="p">;</span>  <span class="c1">// pointer to the first element in the array</span>
<span class="p">};</span>
</code></pre></div>
<p><strong>Increment and Decrement Operators</strong></p>

<p>The increment (++) and decrement (--) operators are most often implemented for iterator classes. These operators let the class move between the elements of a sequence.</p>

<p>Classes that define increment or decrement operators should define both the prefix and postfix versions. These operators usually should be defined as members.</p>

<p><strong>Defining Prefix Increment/Decrement Operators</strong></p>

<p>To be consistent with the built-in operators, the prefix operators should return a reference to the incremented or decremented object.</p>
<div class="highlight"><pre><code class="language-C++" data-lang="C++"><span class="c1">// prefix: return a reference to the incremented/decremented object</span>
<span class="n">StrBlobPtr</span><span class="o">&amp;</span> <span class="n">StrBlobPtr</span><span class="o">::</span><span class="k">operator</span><span class="o">++</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// if curr already points past the end of the container, can&#39;t increment it</span>
    <span class="n">check</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="s">&quot;increment past end of StrBlobPtr&quot;</span><span class="p">);</span>
    <span class="o">++</span><span class="n">curr</span><span class="p">;</span>  <span class="c1">// advance the current state</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">StrBlobPtr</span><span class="o">&amp;</span> <span class="n">StrBlobPtr</span><span class="o">::</span><span class="k">operator</span><span class="o">--</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// if curr is zero, decrementing it will yield an invalid subscript</span>
    <span class="o">--</span><span class="n">curr</span><span class="p">;</span>  <span class="c1">// move the current state back one element</span>
    <span class="n">check</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;decrement past begin of StrBlobPtr&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p><strong>Differentiating Prefix and Postfix Operators</strong></p>

<p>The postfix versions take an extra (unused) parameter of type int. Its sole purpose is to distinguish a postfix function from the prefix version.</p>

<p>To be consistent with the built-in operators, the postfix operators should return the old (unincremented or undecremented) value. That value is
returned as a value, not a reference.</p>
<div class="highlight"><pre><code class="language-C++" data-lang="C++"><span class="k">class</span> <span class="nc">StrBlobPtr</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">// increment and decrement</span>
    <span class="n">StrBlobPtr</span> <span class="k">operator</span><span class="o">++</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>  <span class="c1">// postfix operators</span>
    <span class="n">StrBlobPtr</span> <span class="k">operator</span><span class="o">--</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
    <span class="c1">// other members as before</span>
<span class="p">};</span>
</code></pre></div>
<p><strong>Calling the Postfix Operators Explicitly</strong></p>

<p>If we want to call the postfix version using a function call, then we must pass a value for the integer argument. The value passed usually is ignored but is necessary in order to tell the compiler to use the postfix version.</p>
<div class="highlight"><pre><code class="language-C++" data-lang="C++"><span class="n">StrBlobPtrp</span><span class="p">(</span><span class="n">a1</span><span class="p">);</span> <span class="c1">// p points to the vector inside a1</span>
<span class="n">p</span><span class="p">.</span><span class="k">operator</span><span class="o">++</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>  <span class="c1">// call postfix operator++</span>
<span class="n">p</span><span class="p">.</span><span class="k">operator</span><span class="o">++</span><span class="p">();</span>  <span class="c1">// call prefix  operator++</span>
</code></pre></div>
<p><strong>Member Access Operators</strong></p>

<p>The dereference (<em>) and arrow (-&gt;) operators are often used in classes that
represent iterators and in smart pointer classes.Operator arrow must be a member. The dereference operator is not required to be a member but usually should be a member as well.
``` C++
class StrBlobPtr {
public:
    std::string&amp; operator</em>() const
    { auto p = check(curr, &quot;dereference past end&quot;);
    return (<em>p)[curr];  // (</em>p) is the vector to which this object points
    }
    std::string* operator-&gt;() const
    { // delegate the real work to the dereference operator
    return &amp; this-&gt;operator*();
    }
    // other members as before
};
```</p>

<p><strong>Constraintson the Return from Operator Arrow</strong></p>

<p>The overloaded arrow operator must return either a pointer to a class type or an object of a class type that defines its own operator arrow.</p>

<p><strong>Function-Call Operator</strong></p>

<p>Classes that overload the call operator allow objects of its type to be used as if they were a function. Because such classes can also store state, they can be more flexible than ordinary functions.</p>
<div class="highlight"><pre><code class="language-C++" data-lang="C++"><span class="k">struct</span> <span class="n">absInt</span> <span class="p">{</span>
<span class="kt">int</span> <span class="k">operator</span><span class="p">()(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
<span class="k">return</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="o">-</span><span class="nl">val</span> <span class="p">:</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
<span class="n">inti</span> <span class="o">=</span> <span class="o">-</span><span class="mi">42</span><span class="p">;</span>
<span class="n">absInt</span> <span class="n">absObj</span><span class="p">;</span>  <span class="c1">// object that has a function-call operator</span>
<span class="kt">int</span> <span class="n">ui</span> <span class="o">=</span> <span class="n">absObj</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="c1">// passes i to absObj.operator()</span>
</code></pre></div>
<p>The function-call operator must be a member function. A class may define
multiple versions of the call operator, each of which must differ as to the
number or types of their parameters.</p>

<p>Objects of classes that define the call operator are referred to as <strong>function objects</strong>.Such objects “act like functions” because we can call them.</p>

<p><strong>Function-Object Classes with State</strong></p>

<p>Function objects are most often used as arguments to the generic algorithms. For example, we can use the library for_each algorithm.</p>
<div class="highlight"><pre><code class="language-C++" data-lang="C++"><span class="k">class</span> <span class="nc">PrintString</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="n">PrintString</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">o</span> <span class="o">=</span> <span class="n">cout</span><span class="p">,</span> <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="sc">&#39; &#39;</span><span class="p">)</span><span class="o">:</span>
<span class="n">os</span><span class="p">(</span><span class="n">o</span><span class="p">),</span> <span class="n">sep</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="n">sep</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
<span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">;</span>  <span class="c1">// stream on which to write</span>
<span class="kt">char</span> <span class="n">sep</span><span class="p">;</span>  <span class="c1">// character to print after each output</span>
<span class="p">};</span>

<span class="n">PrintString</span> <span class="n">printer</span><span class="p">;</span>  <span class="c1">// uses the defaults; prints to cout</span>
<span class="n">printer</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>  <span class="c1">// prints s followed by a space on cout</span>
<span class="n">PrintString</span> <span class="nf">errors</span><span class="p">(</span><span class="n">cerr</span><span class="p">,</span> <span class="sc">&#39;\n&#39;</span><span class="p">);</span>
<span class="n">errors</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>  <span class="c1">// prints s followed by a newline on cerr</span>

<span class="n">for_each</span><span class="p">(</span><span class="n">vs</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">vs</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">PrintString</span><span class="p">(</span><span class="n">cerr</span><span class="p">,</span> <span class="sc">&#39;\n&#39;</span><span class="p">));</span>
</code></pre></div>
<p><strong>Lambdas Are Function Objects</strong></p>

<p>When we write a lambda, the compiler translates that expression into an unnamed object of an unnamed class.The classes generated from a lambda contain an overloaded function-call operator.</p>
<div class="highlight"><pre><code class="language-C++" data-lang="C++"><span class="c1">// sort words by size, but maintain alphabetical order for words of the same size</span>
<span class="n">stable_sort</span><span class="p">(</span><span class="n">words</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">words</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
<span class="p">[](</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span> <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">size</span><span class="p">();});</span>

<span class="k">class</span> <span class="nc">ShorterString</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s1</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s2</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span> <span class="k">return</span> <span class="n">s1</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">s2</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="p">}</span>
<span class="p">};</span>

<span class="n">stable_sort</span><span class="p">(</span><span class="n">words</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">words</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">ShorterString</span><span class="p">());</span>
</code></pre></div>
<p><strong>Classes Representing Lambdas with Captures</strong></p>
<div class="highlight"><pre><code class="language-C++" data-lang="C++"><span class="c1">// get an iterator to the first element whose size() is &gt;= sz</span>
<span class="k">auto</span> <span class="n">wc</span> <span class="o">=</span> <span class="n">find_if</span><span class="p">(</span><span class="n">words</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">words</span><span class="p">.</span><span class="n">end</span><span class="p">(),[</span><span class="n">sz</span><span class="p">](</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">SizeComp</span> <span class="p">{</span>
<span class="n">SizeComp</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span><span class="o">:</span> <span class="n">sz</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span> <span class="c1">// parameter for each captured variable</span>
<span class="c1">// call operator with the same return type, parameters, and body as the lambda</span>
<span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span> <span class="k">return</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">sz</span><span class="p">;</span> <span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
<span class="kt">size_t</span> <span class="n">sz</span><span class="p">;</span> <span class="c1">// a data member for each variable captured by value</span>
<span class="p">};</span>

<span class="c1">// get an iterator to the first element whose size() is &gt;= sz</span>
<span class="k">auto</span> <span class="n">wc</span> <span class="o">=</span> <span class="n">find_if</span><span class="p">(</span><span class="n">words</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">words</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">SizeComp</span><span class="p">(</span><span class="n">sz</span><span class="p">));</span>
</code></pre></div>
<p><strong>Library-Defined Function Objects</strong></p>

<p>The standard library defines a set of classes that represent the arithmetic, relational,and logical operators. Each class defines a call operator that applies the named operation. These classes are templates to which we supply a single type. That type specifies the parameter type for the call operator.</p>

<p><img src="http://i.imgur.com/8UZnARL.jpg" alt=""></p>
<div class="highlight"><pre><code class="language-C++" data-lang="C++"><span class="n">plus</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">intAdd</span><span class="p">;</span>  <span class="c1">// function object that can add two int values</span>
<span class="n">negate</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">intNegate</span><span class="p">;</span>  <span class="c1">// function object that can negate an int value</span>
<span class="c1">// uses intAdd::operator(int, int) to add 10 and 20</span>
<span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">intAdd</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>  <span class="c1">// equivalent to sum = 30</span>
<span class="n">sum</span> <span class="o">=</span> <span class="n">intNegate</span><span class="p">(</span><span class="n">intAdd</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">));</span>  <span class="c1">// equivalent to sum = 30</span>
<span class="c1">// uses intNegate::operator(int) to generate -10 as the second parameter</span>
<span class="c1">// to intAdd::operator(int, int)</span>
<span class="n">sum</span> <span class="o">=</span> <span class="n">intAdd</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">intNegate</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span>  <span class="c1">// sum = 0</span>
</code></pre></div>
<p><strong>Using a Library Function Object with the Algorithms</strong></p>

<p>The function-object classes that represent operators are often used to override the default operator used by an algorithm. </p>
<div class="highlight"><pre><code class="language-C++" data-lang="C++"><span class="c1">// passes a temporary function object that applies the &lt; operator to two strings</span>
<span class="n">sort</span><span class="p">(</span><span class="n">svec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">svec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">greater</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="p">());</span>
<span class="n">sort</span><span class="p">(</span><span class="n">svec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">svec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">less</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="p">());</span>
</code></pre></div>
<p><strong>Callable Objects and function</strong></p>

<p>C++ has several kinds of callable objects: functions and pointers to functions,lambdas, objects created by bind, and classes that overload the function-call operator.</p>

<p>two callable objects with different types may share the same <strong>call
signature</strong>. The call signature specifies the type returned by a call to the object and the argument type(s) that must be passed in the call. A call signature corresponds to a function type. For example: int(int,int).</p>

<p><strong>The Library function Type</strong></p>

<p><strong>function</strong> is a template. As with other templates we’ve used, we must specify additional information when we create a function type. In this case, that information is the <strong>call signature</strong> of the objects that this particular function type can represent.</p>
<div class="highlight"><pre><code class="language-C++" data-lang="C++"><span class="c1">// table of callable objects corresponding to each binary operator</span>
<span class="c1">// all the callables must take two ints and return an int</span>
<span class="c1">// an element can be a function pointer, function object, or lambda</span>
<span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span><span class="o">&gt;&gt;</span> <span class="n">binops</span> <span class="o">=</span> <span class="p">{</span>
<span class="p">{</span><span class="s">&quot;+&quot;</span><span class="p">,</span> <span class="n">add</span><span class="p">},</span>  <span class="c1">// function pointer</span>
<span class="p">{</span><span class="s">&quot;-&quot;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">minus</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">()},</span>  <span class="c1">// library function object</span>
<span class="p">{</span><span class="s">&quot;/&quot;</span><span class="p">,</span>  <span class="n">div</span><span class="p">()},</span>  <span class="c1">// user-defined function object</span>
<span class="p">{</span><span class="s">&quot;*&quot;</span><span class="p">,</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">i</span> <span class="o">*</span> <span class="n">j</span><span class="p">;</span> <span class="p">}},</span> <span class="c1">// unnamed</span>
<span class="n">lambda</span>
<span class="p">{</span><span class="s">&quot;%&quot;</span><span class="p">,</span> <span class="n">mod</span><span class="p">}</span> <span class="p">};</span>  <span class="c1">// named lambda object</span>

<span class="n">binops</span><span class="p">[</span><span class="s">&quot;+&quot;</span><span class="p">](</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">);</span> <span class="c1">// calls add(10, 5)</span>
<span class="n">binops</span><span class="p">[</span><span class="s">&quot;-&quot;</span><span class="p">](</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span> <span class="c1">// uses the call operator of the minus&lt;int&gt; object</span>
<span class="n">binops</span><span class="p">[</span><span class="s">&quot;/&quot;</span><span class="p">](</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span> <span class="c1">// uses the call operator of the div object</span>
<span class="n">binops</span><span class="p">[</span><span class="s">&quot;*&quot;</span><span class="p">](</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span> <span class="c1">// calls the lambda function object</span>
<span class="n">binops</span><span class="p">[</span><span class="s">&quot;%&quot;</span><span class="p">](</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span> <span class="c1">// calls the lambda function object</span>
</code></pre></div>
<p>The function class in the new library is not related to classes named
unary<em>function and binary</em>function that were part of earlier versions
of the library. These classes have been deprecated by the more general bind
function.</p>

<p><strong>Conversion Operators</strong></p>

<p>A conversion operatoris a special kind of member function that converts a value of a class type to a value of some other type. A conversion function typically has the general form <strong>operator type() const;</strong></p>

<p>where type represents a type. Conversion operators can be defined for any type (other than void) that can be a function return type. Conversions to
an array or a function type are not permitted. Conversions to pointer types—both data and function pointers—and to reference types are allowed.</p>

<p>Conversion operators have no explicitly stated return type and no parameters, and they must be defined as member functions. Conversion operations ordinarily should not change the object they are converting. As a result, conversion operators usually should be defined as const members.</p>

<p><strong>Defining a Class with a Conversion Operator</strong></p>
<div class="highlight"><pre><code class="language-C++" data-lang="C++"><span class="k">class</span> <span class="nc">SmallInt</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="n">SmallInt</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span><span class="o">:</span> <span class="n">val</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">255</span><span class="p">)</span>
<span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">out_of_range</span><span class="p">(</span><span class="s">&quot;Bad SmallInt value&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">operator</span> <span class="kt">int</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">val</span><span class="p">;</span> <span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
<span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">val</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">SmallInt</span> <span class="n">si</span><span class="p">;</span>
<span class="n">si</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="c1">// implicitly converts 4 to SmallInt then calls SmallInt::operator=</span>
<span class="n">si</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span> <span class="c1">// implicitly converts si to int followed by integer addition</span>
</code></pre></div>
<p><strong>Conversion Operators Can Yield Suprising Results</strong></p>

<p>In practice, classes rarely provide conversion operators. Too often users are more likely to be surprised if a conversion happens automatically than to be helped by the existence of the conversion. However, there is one important exception to this rule of thumb: It is not uncommon for classes to define conversions to bool.</p>
<div class="highlight"><pre><code class="language-C++" data-lang="C++"><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="n">cin</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">;</span> <span class="c1">// this code would be legal if the conversion to bool were not explicit!</span>
</code></pre></div>
<p>This program attempts to use the output operator on an input stream. There is no &lt;&lt; defined for istream, so the code is almost surely in error. However, this code could use the bool conversion operator to convert cin to bool. The resulting bool value would then be promoted to int and used as the left-hand operand to the built-in version of the left-shift operator. The promoted boolvalue (either 1 or 0) would be shifted left 42 positions.</p>

<p><strong>explicit Conversion Operators</strong></p>

<p>To prevent such problems, the new standard introduced explicit conversion operators.</p>
<div class="highlight"><pre><code class="language-C++" data-lang="C++"><span class="k">class</span> <span class="nc">SmallInt</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="c1">// the compiler won&#39;t automatically apply this conversion</span>
<span class="k">explicit</span> <span class="k">operator</span> <span class="kt">int</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">val</span><span class="p">;</span> <span class="p">}</span>
<span class="c1">// other members as before</span>
<span class="p">};</span>

<span class="n">SmallInt</span> <span class="n">si</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>  <span class="c1">// ok: the SmallInt constructor is not explicit</span>
<span class="n">si</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span> <span class="c1">// error: implicit is conversion required, but operator int is explicit</span>
<span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">si</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span> <span class="c1">// ok: explicitly request the conversion</span>
</code></pre></div>
<p>If the conversion operator is explicit, we can still do the conversion. However, with one exception, we must do so explicitly through a cast.
The exception is that the compiler will apply an explicit conversion to an
expression used as a <strong>condition</strong>. </p>

<p><strong>Conversion to bool</strong></p>

<p>In earlier versions of the library, the IO types defined a conversion to void*. They did so to avoid the kinds of problems illustrated above. Under the new standard, the IO library instead defines an explicit conversion to bool.
<code>C++
while(std::cin &gt;&gt; value)
</code>
The condition in the while executes the input operator, which reads into value and returns cin. To evaluate the condition, cin is implicitly converted by the istream operator bool conversion function. That function returns true if the conditionstate of cin is good, and false other wise.</p>

<p>Conversion to bool is usually intended for use in conditions. As a result,
operator bool ordinarily should be defined as explicit.</p>

<ul class="pager">
  
  <li class="previous"><a  href="/c++/2014-07/copy-control.html" title="Copy Control">&larr; Prev</a></li>
  
  
  <li class="next"><a href="/c++/2014-07/object-oriented-programming.html" title="Object-Oriented Programming">Next &rarr;</a></li>
  
</ul>



</div>

        </div>
      </article>

      <footer class="footer text-center">
  <p>&copy; 2015 <a href="" title="">liuguichao</a>. with Help from <a href="//jekyllrb.com/" title="Transform your plain text into static websites and blogs.">Jekyll</a> and <a href="//getbootstrap.com/" title="Bootstrap is the most popular HTML, CSS, and JS framework for developing responsive, mobile first projects on the web.">Bootstrap</a></p>
  <p>Articles are licensed under <a href="//creativecommons.org/licenses/by/3.0/" title="CC BY 3.0 License">the CC BY 3.0</a></p>
</footer>

    </div>

    <script src="/assets/js/jquery.min.js"></script>
    <script src="/assets/js/bootstrap.min.js"></script>
    <script src="/assets/js/webcore.js"></script>

    

    
  </body>
</html>
