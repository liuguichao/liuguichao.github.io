<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>classes concept - My study notes</title>
  <meta name="description" content="">
  <meta name="keywords" content="">
  <meta name="author" content="liuguichao">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="shortcut icon" href="/favicon.png">
  <link rel="canonical" href="/c++/2014-07/classes-concept.html">

  <link rel="stylesheet" href="/assets/css/style.css" media="all">

  <!-- atom & rss feed -->
  <link href="/rss.xml" type="application/rss+xml" rel="alternate" title="My study notes RSS Feed">
  <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="My study notes ATOM Feed">

  <!-- fav and touch icons  -->
  <!-- Update these with your own images
  <link rel="shortcut icon" href="images/favicon.ico">
  <link rel="apple-touch-icon" href="images/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.png">
  -->

  <meta name="renderer" content="webkit|ie-stand">

  <meta name="baidu-site-verification" content="BvD3CNBzK6" />
  <meta name="msvalidate.01" content="FE0D1D87A075E1003B82C7446EE360ED" />
</head>


  <body>
    <div class="container">
      <!--[if lt IE 9]>
<div class="alert alert-warning">
  <p>Your Internet Explorer is not supported. Please upgrade your Internet Explorer to version 9+, or use latest <a href="http://www.google.com/chrome/" target="_blank" class="alert-link">Google chrome</a>、<a href="http://www.mozilla.org/firefox/" target="_blank" class="alert-link">Mozilla Firefox</a>.</p>
  <p>If you are using IE 9 or later, make sure you <a href="http://windows.microsoft.com/en-us/internet-explorer/use-compatibility-view#ie=ie-8" target="_blank" class="alert-link">turn off "Compatibility view"</a>.</p>
</div>
<![endif]-->
<header class="header">
  <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
  <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target=".bs-navbar-collapse">
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
  </button>
  <div class="title"><a title="My study notes" href="/">My study notes</a></div>
  <ul class="nav navbar-nav collapse navbar-collapse bs-navbar-collapse navbar-right">
    <li>
    <form id="search-form" class="form-group has-success visible-lg" role="form">
      <input type="text" class="form-control input-sm" placeholder="Search" id="query">
    </form>
    </li>
    <li><a href="/archive.html" title="Archive"><span class='fa fa-archive fa-2x'></span></a></li>
    <li><a href="/categories.html" title="Categories" rel="nofollow"><span class='fa fa-navicon fa-2x'></span></a></li>
    <li><a href="/tags.html" title="Tags" rel="nofollow"><span class='fa fa-tags fa-2x'></span></a></li>
    <li><a href="/about.html" title="About"><span class='fa fa-user fa-2x'></span></a></li>
    
    <li><a href="https://github.com/liuguichao" target="_blank" title="Github" rel="nofollow"><span class='fa fa-github fa-2x'></span></a></li>
    
    
    
    
    

    <li><a href="/rss.xml" target="_blank" title="RSS" rel="nofollow"><span class='fa fa-rss fa-2x'></span></a></li>
  </ul>
</header>


      <article class="wrapper">
        <div id="search-loader" class="img-wrap">
          <div class="loading">
            <img src="/assets/img/loading.png">
          </div>
        </div>
        <div class="row clearfix">
          <div class="col-md-12">
<h2 class="title"> classes concept <time class="small">2014.07.10</time></h2>
<p><strong>Note</strong></p>

<ol>
<li>Functions defined in the class are implicitly <em>inline</em></li>
<li>Ordinarily,nonmember functions that are part of the interface of a class should be declared in the same header as the class itself.</li>
<li>The compiler generates a default constructor automatically only if a class declares noconstructors.</li>
<li>Classes that have members of built-in or compound type usually should rely on the synthesized default constructor only if all such members have in-class initializers.</li>
<li>The only difference between using class and using struct to define a class is the default access level.As a matter of programming style, when we define a class intending for all of its members to be public, we use struct. If we intend to have private members,then we use class.</li>
<li>inline member functions should be defined in the same header as the corresponding class definition.</li>
<li>When we provide an in-class initializer, we must do so following an = sign or inside braces.</li>
<li>Functions that return a reference are lvalues, which means that they return the object itself, not a copy of the
object.A const member function that returns *this as a reference should have a return type that is a reference to const.</li>
<li>Each class controls which classes or functions are its friends.</li>
<li>Member function definitions are processed after the compiler processes all of the declarations in the class.</li>
<li>Definitions of type names usually should appear at the beginning of a class.That way any member that uses that type will be seen after the type name has already been defined.</li>
<li>We must use the constructor initializer list to provide values for members that are const, reference, or of a class type that does not have a default constructor.</li>
<li>It is a good idea to write constructor initializers in the same order as the members are declared. Moreover, when possible, avoid using members to initialize other members.</li>
<li>As with any class member, when we refer to a class static member outside the class body, we must specify the class in which the member is defined.The <em>static</em> keyword, however, is used only on the declaration inside the class body.</li>
</ol>

<p><strong>Friends</strong></p>

<p>A class can allow another class or function to access its nonpublic members by making that class or function a <em>friend</em>. A class makes a function its friend by including
a declaration for that function preceded by the keyword <em>friend</em>.</p>

<p>Friend declarations may appear only inside a class definition; they may appear anywhere in the class. Friends are not members of the class and are not affected by
the access control of the section in which they are declared. </p>

<p>To make a friend visible to users of the class, we usually declare each friend (outside the class) in the same header as the class itself. </p>

<p><strong>Benefits of Encapsulation</strong></p>

<ul>
<li>User code cannot inadvertently corrupt the state of an encapsulated object.</li>
<li>The implementation of an encapsulated class can change over time without requiring changes in user-level code.</li>
</ul>

<p><strong>mutable Data Members</strong></p>

<p>It sometimes (but not very often) happens that a class has a data member that we want to be able to modify, even inside a const member function. We indicate such
members by including the <em>mutable</em> keyword in their declaration.A mutable data member is never const, even when it is a member of a const object. Accordingly, a const member function may change a mutable member.</p>

<p><strong>Class Declarations</strong></p>

<p>Because a class is not defined until its class body is complete, a class cannot have data members of its own type. However, a class is considered declared (but not yet defined) as soon as its class name has been seen. Therefore, a class can have data members that are pointers or references to its own type.</p>

<p><strong>Friendship Revisited</strong></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">//Friendship between Classes
class Screen {
// Window_mgr memberscan access the private parts of class Screen
    friend class Window_mgr;
// ... rest of the Screen class
};
//Making A Member Function a Friend
classScreen {
// Window_mgr::clear must have been declared before class Screen
    friend void Window_mgr::clear(ScreenIndex);
// ... rest of the Screen class
};
</code></pre></div>
<p>Making a member function a friend requires careful structuring of our programs to accommodate interdependencies among the declarations and definitions. In this example, we must order our program as follows:
•First, define the Window_mgr class, which declares, but cannot define, clear.Screen must be declared before clear can use the members of Screen.
•Next, define class Screen, including a friend declaration for clear.
•Finally, define clear, which can now refer to the members in Screen.</p>

<p><strong>Order of Member Initialization</strong></p>

<p>Members are initialized in the order in which they appear in the class definition: The first member is initialized first, then the next, and so on. The order in which initializers appear in the constructor initializer list does not change the order of initialization.
The order of initialization often doesn’t matter. However, if one member is initialized in terms of another, then the order in which members are initialized is crucially
important.</p>

<p><strong>Default Arguments and Constructors</strong></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">// defines the default constructor as well as one that takes a string argument
Sales_data(std::string s = &quot;&quot;): bookNo(s) { }
</code></pre></div>
<p>we can call this constructor with no arguments, this
constructor defines a default constructor for our class.
A constructor that supplies default arguments for all its parameters also defines the default constructor.</p>

<p><strong>Delegating Constructors</strong></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class Sales_data {
public:
// nondelegating constructor initializes members from corresponding arguments
Sales_data(std::string s, unsigned cnt, double price):
bookNo(s), units_sold(cnt), revenue(cnt*price) {
}
// remaining constructors all delegate to another constructor
Sales_data(): Sales_data(&quot;&quot;, 0, 0) {}
Sales_data(std::string s): Sales_data(s, 0,0) {}
Sales_data(std::istream &amp;is): Sales_data()
{ read(is, *this); }
// other members as before
};
</code></pre></div>
<p><strong>Implicit Class-Type Conversions</strong></p>

<p>A constructor that can be called with a single argument defines an implicit conversion from the constructor’s parameter type to the class type.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">// ok: explicit conversion to string, implicit conversion to Sales_data
item.combine(string(&quot;9-999-99999-9&quot;));
// ok: implicit conversion to string, explicit conversion to Sales_data
item.combine(Sales_data(&quot;9-999-99999-9&quot;));
</code></pre></div>
<p>We can prevent the use of a constructor in a context that requires an implicit conversion by declaring the constructor as <em>explicit</em>:
explicit Sales_data(std::istream&amp;);The <em>explicit</em> keyword is used only on the constructor declaration inside
the class. It is not repeated on a definition made outside the class body.explicit Constructors Can Be Used Only for Direct Initialization.When a constructor is declared <em>explicit</em>, it can be used only with the
direct form of initialization. Moroever, the compiler will not use this constructor in an automatic conversion.</p>

<p><strong>Aggregate Classes</strong></p>

<p>An aggregate class gives users direct access to its members and has special initialization syntax. A class is an aggregate if •All of its data members are public
•It does not define any constructors
•It has no in-class initializers
•It has no base classes or virtual functions</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">struct Data {int ival;string s;};
// val1.ival = 0; val1.s = string(&quot;Anna&quot;)
Data val1 = { 0, &quot;Anna&quot; };
</code></pre></div>
<p><strong>static Class Members</strong></p>

<p>Classes sometimes need members that are associated with the class, rather than with individual objects of the class type. For example, a bank account class might need a data member to represent the current prime interest rate. In this case, we’d want to associate the rate with the class, not with each individual object. From an efficiency
standpoint, there’d be no reason for each object to store the rate. Much more importantly, if the rate changes, we’d want each object to use the new value.</p>

<p><strong>Declaring static Members</strong></p>

<p>We say a member is associated with the class by adding the keyword <em>static</em> to its declaration. Like any other member, static members can be public or private.The type of a static data member can be const, reference, array, class type, and so forth.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">classAccount {
public:
void calculate() { amount += amount * interestRate; }
static double rate() { return interestRate; }
static void rate(double);
private:
std::string owner;
double amount;
static double interestRate;
static double initRate();
};
</code></pre></div>
<p>The static members of a class exist outside any object. Objects do not contain data associated with static data members. Thus, each Account object will contain two
data members—owner and amount. There is only one interestRate object that will be shared by all the Account objects.Similarly, static member functions are not bound to any object; they do not have a this pointer. As a result, static member functions may not be declared as const, and we may not refer to this in the body of a static member. This restriction applies both to explicit uses of this and to implicit uses of this by calling a nonstatic member.We can access a static member directly through the scope operator:Account::rate().Member functions can use static members directly, without the scope operator.
When we define a static member outside the class, we
do not repeat the static keyword. The keyword appears only with the declaration inside the class body.</p>

<p>Because static data members are not part of individual objects of the class type,they are not defined when we create objects of the class. As a result, they are not
initialized by the class’ constructors. Moreover, in general, we may not initialize a static member inside the class. Instead, we must define and initialize each static
data member outside the class body. Like any other object, a static data member may be defined only once.Like global objects, static data members are defined outside any
function. Hence, once they are defined, they continue to exist until the program completes.</p>

<p><strong>C++ 11</strong></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">typedef std::string::size_type pos;
// alternative way to declare 
using pos = std::string::size_type;

// needed because Screen has another constructor
Screen() = default; 

//specify default value with an in-class initializer
std::vector&lt;Screen&gt; screens{Screen(24, 80, &#39; &#39;) };
</code></pre></div>
<ul class="pager">
  
  <li class="previous"><a  href="/algorithms/2014-07/fibonacci-sequence.html" title="fibonacci sequence">&larr; Prev</a></li>
  
  
  <li class="next"><a href="/c++/2014-07/the-io-library.html" title="The IO Library">Next &rarr;</a></li>
  
</ul>



</div>

        </div>
      </article>

      <footer class="footer text-center">
  <p>&copy; 2015 <a href="" title="">liuguichao</a>. with Help from <a href="//jekyllrb.com/" title="Transform your plain text into static websites and blogs.">Jekyll</a> and <a href="//getbootstrap.com/" title="Bootstrap is the most popular HTML, CSS, and JS framework for developing responsive, mobile first projects on the web.">Bootstrap</a></p>
  <p>Articles are licensed under <a href="//creativecommons.org/licenses/by/3.0/" title="CC BY 3.0 License">the CC BY 3.0</a></p>
</footer>

    </div>

    <script src="/assets/js/jquery.min.js"></script>
    <script src="/assets/js/bootstrap.min.js"></script>
    <script src="/assets/js/webcore.js"></script>

    

    
  </body>
</html>
